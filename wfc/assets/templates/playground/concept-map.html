<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WFC Concept Map</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --bg: #0f172a; --surface: #1e293b; --border: #334155;
    --text: #e2e8f0; --dim: #94a3b8; --accent: #3b82f6;
    --accent-hover: #2563eb;
    --font-body: 'Space Grotesk', system-ui, sans-serif;
    --font-mono: 'JetBrains Mono', 'SF Mono', Consolas, monospace;
  }

  @media (prefers-color-scheme: light) {
    :root {
      --bg: #f1f5f9; --surface: #ffffff; --border: #e2e8f0;
      --text: #1e293b; --dim: #64748b; --accent: #2563eb;
      --accent-hover: #1d4ed8;
    }
  }

  @media (prefers-reduced-motion: reduce) {
    *, *::before, *::after {
      animation-duration: 0.01ms !important;
      transition-duration: 0.01ms !important;
    }
  }

  body {
    font-family: var(--font-body);
    background: var(--bg); color: var(--text); height: 100vh;
    display: grid; grid-template-columns: 1fr 260px; grid-template-rows: auto 1fr;
  }
  .toolbar {
    grid-column: 1 / 3; background: var(--surface); padding: 10px 20px;
    display: flex; align-items: center; gap: 12px;
    border-bottom: 1px solid var(--border);
  }
  .toolbar h2 { color: var(--accent); font-size: 16px; margin-right: 8px; font-weight: 600; }
  .toolbar button {
    padding: 6px 14px; background: var(--bg); color: var(--text);
    border: 1px solid var(--border); border-radius: 6px; cursor: pointer;
    font-size: 11px; font-family: var(--font-mono); transition: background 0.15s;
  }
  .toolbar button:hover { background: var(--border); }
  .toolbar button.active { background: var(--accent); border-color: var(--accent); color: #fff; }
  .toolbar .sep { width: 1px; height: 24px; background: var(--border); }
  canvas {
    display: block; cursor: crosshair; background: var(--bg);
  }
  .panel {
    background: var(--surface); padding: 16px; overflow-y: auto;
    border-left: 1px solid var(--border);
  }
  .panel h3 { font-size: 13px; color: var(--accent); margin-bottom: 12px; font-weight: 600; }
  .panel label {
    display: block; font-size: 10px; color: var(--dim);
    text-transform: uppercase; letter-spacing: 1.2px; margin: 10px 0 4px;
    font-family: var(--font-mono); font-weight: 600;
  }
  .panel input[type="text"] {
    width: 100%; padding: 6px 10px; background: var(--bg);
    border: 1px solid var(--border); border-radius: 4px; color: var(--text);
    font-size: 13px; font-family: var(--font-body);
  }
  .panel select {
    width: 100%; padding: 6px 10px; background: var(--bg);
    border: 1px solid var(--border); border-radius: 4px; color: var(--text);
    font-size: 13px; font-family: var(--font-body);
  }
  .node-list { margin-top: 16px; }
  .node-item {
    padding: 6px 10px; margin-bottom: 4px; border-radius: 4px;
    font-size: 12px; cursor: pointer; display: flex;
    align-items: center; gap: 8px; transition: background 0.15s;
  }
  .node-item:hover { background: var(--border); }
  .node-dot {
    width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0;
  }
  .node-item .del {
    margin-left: auto; color: #f87171; cursor: pointer;
    font-size: 14px; opacity: 0.5; transition: opacity 0.15s;
  }
  .node-item .del:hover { opacity: 1; }
  .help { font-size: 11px; color: var(--dim); margin-top: 16px; line-height: 1.5; font-family: var(--font-mono); }

  @media (max-width: 768px) {
    body { grid-template-columns: 1fr; }
    .panel { border-left: none; border-top: 1px solid var(--border); max-height: 250px; }
  }
</style>
</head>
<body>

<div class="toolbar">
  <h2>Concept Map</h2>
  <button id="modeAdd" class="active" onclick="setMode('add')">Add Node</button>
  <button id="modeConnect" onclick="setMode('connect')">Connect</button>
  <button id="modeMove" onclick="setMode('move')">Move</button>
  <div class="sep"></div>
  <button onclick="clearAll()">Clear</button>
  <button onclick="exportMap()">Export JSON</button>
</div>

<canvas id="canvas"></canvas>

<div class="panel">
  <h3>New Node</h3>
  <label>Label</label>
  <input type="text" id="nodeLabel" placeholder="Node name" value="">
  <label>Category</label>
  <select id="nodeCategory">
    <option value="core" style="color:#3b82f6">Core</option>
    <option value="feature" style="color:#06b6d4">Feature</option>
    <option value="external" style="color:#f59e0b">External</option>
    <option value="data" style="color:#22c55e">Data</option>
  </select>

  <h3 style="margin-top:20px">Nodes</h3>
  <div class="node-list" id="nodeList"></div>

  <div class="help">
    <strong>Add</strong>: Click canvas to place node<br>
    <strong>Connect</strong>: Click source then target<br>
    <strong>Move</strong>: Drag nodes around<br>
    <strong>Delete</strong>: Click X in node list
  </div>
</div>

<script>
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  let nodes = [];
  let edges = [];
  let mode = 'add';
  let connectSource = null;
  let dragNode = null;
  let dragOffset = { x: 0, y: 0 };

  const COLORS = {
    core: '#3b82f6', feature: '#06b6d4',
    external: '#f59e0b', data: '#22c55e'
  };
  const NODE_R = 30;

  function resize() {
    const rect = canvas.parentElement
      ? canvas.getBoundingClientRect()
      : { width: 800, height: 600 };
    canvas.width = canvas.offsetWidth;
    canvas.height = canvas.offsetHeight;
    draw();
  }
  window.addEventListener('resize', resize);

  function setMode(m) {
    mode = m;
    connectSource = null;
    document.getElementById('modeAdd').classList.toggle('active', m === 'add');
    document.getElementById('modeConnect').classList.toggle(
      'active', m === 'connect'
    );
    document.getElementById('modeMove').classList.toggle('active', m === 'move');
    canvas.style.cursor = m === 'move' ? 'grab' : 'crosshair';
  }

  function findNode(x, y) {
    for (let i = nodes.length - 1; i >= 0; i--) {
      const n = nodes[i];
      const dx = x - n.x, dy = y - n.y;
      if (dx * dx + dy * dy <= NODE_R * NODE_R) return n;
    }
    return null;
  }

  canvas.addEventListener('mousedown', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const hit = findNode(x, y);

    if (mode === 'add' && !hit) {
      const label = document.getElementById('nodeLabel').value || `Node ${nodes.length + 1}`;
      const cat = document.getElementById('nodeCategory').value;
      nodes.push({ id: Date.now(), x, y, label, category: cat });
      document.getElementById('nodeLabel').value = '';
      updateNodeList();
      draw();
    } else if (mode === 'connect') {
      if (!connectSource && hit) {
        connectSource = hit;
      } else if (connectSource && hit && hit !== connectSource) {
        const exists = edges.some(
          e => (e.from === connectSource.id && e.to === hit.id) ||
               (e.from === hit.id && e.to === connectSource.id)
        );
        if (!exists) edges.push({ from: connectSource.id, to: hit.id });
        connectSource = null;
        draw();
      }
    } else if (mode === 'move' && hit) {
      dragNode = hit;
      dragOffset = { x: x - hit.x, y: y - hit.y };
      canvas.style.cursor = 'grabbing';
    }
  });

  canvas.addEventListener('mousemove', (e) => {
    if (!dragNode) return;
    const rect = canvas.getBoundingClientRect();
    dragNode.x = e.clientX - rect.left - dragOffset.x;
    dragNode.y = e.clientY - rect.top - dragOffset.y;
    draw();
  });

  canvas.addEventListener('mouseup', () => {
    if (dragNode) {
      dragNode = null;
      canvas.style.cursor = 'grab';
    }
  });

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw grid
    ctx.strokeStyle = '#ffffff08';
    ctx.lineWidth = 1;
    for (let x = 0; x < canvas.width; x += 40) {
      ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
    }
    for (let y = 0; y < canvas.height; y += 40) {
      ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
    }

    // Draw edges
    edges.forEach(edge => {
      const from = nodes.find(n => n.id === edge.from);
      const to = nodes.find(n => n.id === edge.to);
      if (!from || !to) return;

      ctx.beginPath();
      ctx.moveTo(from.x, from.y);
      ctx.lineTo(to.x, to.y);
      ctx.strokeStyle = '#ffffff30';
      ctx.lineWidth = 2;
      ctx.stroke();

      // Arrow
      const angle = Math.atan2(to.y - from.y, to.x - from.x);
      const ax = to.x - Math.cos(angle) * NODE_R;
      const ay = to.y - Math.sin(angle) * NODE_R;
      ctx.beginPath();
      ctx.moveTo(ax, ay);
      ctx.lineTo(
        ax - 10 * Math.cos(angle - 0.4),
        ay - 10 * Math.sin(angle - 0.4)
      );
      ctx.lineTo(
        ax - 10 * Math.cos(angle + 0.4),
        ay - 10 * Math.sin(angle + 0.4)
      );
      ctx.closePath();
      ctx.fillStyle = '#ffffff50';
      ctx.fill();
    });

    // Draw nodes
    nodes.forEach(node => {
      const color = COLORS[node.category] || '#888';

      // Shadow
      ctx.beginPath();
      ctx.arc(node.x + 2, node.y + 2, NODE_R, 0, Math.PI * 2);
      ctx.fillStyle = '#00000040';
      ctx.fill();

      // Circle
      ctx.beginPath();
      ctx.arc(node.x, node.y, NODE_R, 0, Math.PI * 2);
      ctx.fillStyle = color + '20';
      ctx.fill();
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.stroke();

      // Label
      ctx.fillStyle = '#e0e0e0';
      ctx.font = '12px -apple-system, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const maxW = NODE_R * 2 - 8;
      let text = node.label;
      if (ctx.measureText(text).width > maxW) {
        while (ctx.measureText(text + '...').width > maxW && text.length > 1) {
          text = text.slice(0, -1);
        }
        text += '...';
      }
      ctx.fillText(text, node.x, node.y);
    });

    // Connect mode indicator
    if (mode === 'connect' && connectSource) {
      ctx.beginPath();
      ctx.arc(connectSource.x, connectSource.y, NODE_R + 4, 0, Math.PI * 2);
      ctx.strokeStyle = '#e94560';
      ctx.lineWidth = 2;
      ctx.setLineDash([4, 4]);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  function updateNodeList() {
    const list = document.getElementById('nodeList');
    list.innerHTML = '';
    nodes.forEach(n => {
      const item = document.createElement('div');
      item.className = 'node-item';
      item.dataset.id = n.id;

      const dot = document.createElement('span');
      dot.className = 'node-dot';
      dot.style.background = COLORS[n.category] || '#888';

      const labelSpan = document.createElement('span');
      labelSpan.textContent = n.label;

      const del = document.createElement('span');
      del.className = 'del';
      del.textContent = 'x';
      del.addEventListener('click', () => deleteNode(n.id));

      item.appendChild(dot);
      item.appendChild(labelSpan);
      item.appendChild(del);
      list.appendChild(item);
    });
  }

  function deleteNode(id) {
    nodes = nodes.filter(n => n.id !== id);
    edges = edges.filter(e => e.from !== id && e.to !== id);
    updateNodeList();
    draw();
  }

  function clearAll() {
    nodes = [];
    edges = [];
    updateNodeList();
    draw();
  }

  function exportMap() {
    const data = JSON.stringify({ nodes, edges }, null, 2);
    navigator.clipboard.writeText(data).then(() => {
      const btns = document.querySelectorAll('.toolbar button');
      const btn = btns[btns.length - 1];
      btn.textContent = 'Copied!';
      setTimeout(() => btn.textContent = 'Export JSON', 1500);
    });
  }

  setTimeout(resize, 0);
</script>
</body>
</html>

ok I run wfc local and this is the development code.
I want to remove the "installed" version of wfc without losing my development data because I want to get to the version we have in `main` right now. Understood?

---

what do you mean unstaged?

---

.development should move to ~/.wfc/development (thats the new pattern)
same with test-results and validation
and then we deep dive on docs and skills

---

yes nothing lost just moved

---

tell me what is unstaged and why

---

ok lets drop anything that is duplicated.
and lets compare to what is in main right now because I merged a large PR an hour ago

---

gonna need to rbanch because you cant push to main but #1

---

Base directory for this skill: /Users/samfakhreddine/.claude/skills/wfc-pr-comments

# WFC:PR-COMMENTS - Intelligent PR Comment Triage & Fix

**Fetch, triage, fix.** Automates addressing PR review comments from humans, Copilot, CodeRabbit, and other reviewers.

## What It Does

1. **Fetch** all PR comments via `gh` CLI
2. **Triage** each comment against 5 validity criteria
3. **Present** triage summary to user for approval
4. **Fix** valid comments in parallel (subagents by category)
5. **Commit & push** fixes to the PR branch

## Usage

```bash
# Auto-detect PR from current branch
/wfc-pr-comments

# Specific PR number
/wfc-pr-comments 42

# PR URL
/wfc-pr-comments https://github.com/owner/repo/pull/42
```

---

## Workflow

Follow these steps exactly in order.

### Step 1: DETECT PR

Determine which PR to work on:

1. If the user provided a PR number or URL as argument, use that.
2. Otherwise, auto-detect from the current branch:

```bash
gh pr view --json number,url,headRefName,baseRefName,title
```

If no PR is found, tell the user and stop.

Display: `PR #N: <title> (<head> -> <base>)`

### Step 2: FETCH UNRESOLVED COMMENTS

Fetch only **unresolved** review comments from the PR. Use GraphQL — the REST API does not expose thread resolution status.

```bash
# Use the pr_threads helper (preferred — returns thread IDs needed for resolving)
uv run python wfc/scripts/github/pr_threads.py fetch {owner} {repo} {number} --json

# Or raw GraphQL (note: must include thread `id` for later resolution)
gh api graphql -f query='
  query($owner: String!, $repo: String!, $number: Int!) {
    repository(owner: $owner, name: $repo) {
      pullRequest(number: $number) {
        reviewThreads(first: 100) {
          nodes {
            id
            isResolved
            isOutdated
            path
            line
            startLine
            diffSide
            comments(first: 50) {
              nodes {
                id
                body
                author { login }
                createdAt
                path
                diffHunk
                originalLine
              }
            }
          }
        }
      }
    }
  }
' -f owner='{owner}' -f repo='{repo}' -F number={number}
```

**Filter:** Only process threads where `isResolved` is `false`. Skip all resolved threads entirely — they have already been addressed.

Optionally also skip threads where `isOutdated` is `true` (the code has changed since the comment was made), but flag these to the user in the triage table.

Extract from each unresolved thread's first comment:
- `id` — unique identifier
- `author.login` — who wrote it
- `body` — comment text
- `path` — file being commented on
- `line` / `originalLine` — line number
- `diffHunk` — surrounding diff context
- `createdAt` — timestamp

**Deduplication:** If two threads reference the same file + line + substantially identical message, treat them as one.

**Group by file** for display purposes.

If there are zero unresolved comments, tell the user "All review threads are resolved" and stop.

### Step 3: TRIAGE

This is the core intelligence. For each comment, evaluate 5 dimensions and assign a verdict.

**Read each file being commented on** before evaluating (use the Read tool).

#### Dimension 1: ARCHITECTURAL VALIDITY

Does this suggestion align with project patterns?
- Check existing conventions in the file and codebase
- Consider CLAUDE.md / PLANNING.md rules
- A suggestion that contradicts project conventions → lean toward SKIP

#### Dimension 2: SCOPE CHECK

Is this about code in this PR's diff, or asking for unrelated work?
- Comment about code changed in this PR → in scope
- Request for unrelated refactoring → out of scope → SKIP
- Feature request disguised as review comment → SKIP

#### Dimension 3: CORRECTNESS

Is the suggested fix actually correct?
- Would implementing it introduce bugs?
- Does it handle edge cases the reviewer may have missed?
- Is the reviewer wrong about the issue? If so → SKIP with explanation

#### Dimension 4: SEVERITY

- **Critical** (security, data loss, crashes) → always FIX
- **High** (bugs, logic errors) → FIX
- **Medium** (code quality, patterns) → FIX if valid
- **Low** (style, preferences) → FIX if trivial, SKIP if opinionated
- **Info** (questions, suggestions) → RESPOND only

#### Dimension 5: EFFORT vs VALUE

- **Trivial** (1-2 lines) → always FIX
- **Medium** (function-level) → FIX if high value
- **Large** (multi-file refactor) → SKIP, suggest follow-up issue

**Verdict per comment:** `FIX` | `SKIP (reason)` | `RESPOND (reply only)`

### Step 4: PRESENT TRIAGE TO USER

Display a markdown table summarizing the triage:

```
| # | File | Comment (summary) | Verdict | Reason |
|---|------|-------------------|---------|--------|
| 1 | security_hook.py:45 | Add lru_cache to pattern loading | FIX | Valid perf improvement, trivial |
| 2 | orchestrator.py:120 | Rewrite auth flow | SKIP | Out of scope for this PR |
| 3 | README.md:8 | Fix typo "teh" → "the" | FIX | Trivial |
| 4 | consensus.py:30 | Why not use dataclass? | RESPOND | Question, not actionable |
```

Then show summary counts:

```
Summary: 8 FIX, 2 SKIP, 1 RESPOND

Proceed with fixes?
```

**Use AskUserQuestion** to get approval. The user may:
- Approve as-is
- Override specific verdicts (e.g., "skip #1, fix #4")
- Cancel entirely

Apply any user overrides before proceeding.

### Step 5: CATEGORIZE & DELEGATE

Group all `FIX` comments into categories:

| Category | Examples |
|----------|----------|
| **Lint** | Unused imports, formatting, naming conventions |
| **Code Quality** | Caching, error handling, type safety, simplification |
| **Design** | Architecture changes, API modifications, patterns |
| **Docs** | Typos, missing docs, outdated comments |
| **Security** | Vulnerabilities, hardcoded secrets, input validation |

Spawn **1 subagent per category** via the Task tool (run in parallel).

Each subagent receives this prompt:

```
You are fixing PR review comments in category: {category}

PR: #{number} on branch {headRefName}
Repository root: {repo_root}

Comments to address:
{for each comment in this category:}
---
File: {path}:{line}
Comment by {author}: {body}
Diff context:
{diff_hunk}
---
{end for}

Instructions:
1. Read each file mentioned above
2. Apply the fix described in each comment
3. Verify the fix is correct — do not introduce regressions
4. Run relevant tests if they exist (use: uv run pytest {test_file} -v)
5. Run auto-lint on every modified file:
   - Python files: `uv run ruff check --fix {file}` then `uv run black {file}`
   - TypeScript/JS files: `npx prettier --write {file}` (if available)
   - Go files: `gofmt -w {file}` (if available)
   Report any remaining lint errors that couldn't be auto-fixed.
6. Do NOT fix anything not in the comment list above
7. Do NOT make unrelated improvements or refactors
```

For `RESPOND` comments: Do NOT spawn a subagent. Instead, after fixes are committed, use `gh api` to reply to the comment on GitHub with an explanation.

**Auto-lint gate:** Before committing, run a final format check across all modified files:
```bash
uv run black --check wfc/ && uv run ruff check .
```
If black would reformat any file, run `uv run black {modified_files}` first. This prevents CI failures from formatting issues.

### Step 6: COMMIT & PUSH

After all fix subagents complete:

1. Check which files were modified: `git status`
2. Stage all fixed files (by name, not `git add -A`)
3. Create a single commit:

```
fix: address N PR review comments

- {file1}: {brief description of fix}
- {file2}: {brief description of fix}
...

Addresses comments on PR #{number}

Co-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>
```

4. Push to the PR branch:

```bash
git push origin {headRefName}
```

### Step 7: RESOLVE THREADS

After pushing, reply to and resolve every addressed thread using the pr_threads helper.

Build a JSON manifest of all threads:

```python
# manifest.json format
[
  {
    "thread_id": "PRRT_...",           # thread node ID (from fetch --json)
    "message": "Fixed in {commit}: {one-line description of what was done}",
    "action": "fixed"                  # "fixed", "responded", or "skip"
  }
]
```

- **FIX threads** → `"action": "fixed"`, message describes the exact change made and the commit SHA
- **RESPOND threads** → `"action": "responded"`, message is the explanation already provided
- **SKIP threads** → `"action": "skip"`, these are NOT resolved (leave open for human decision)

Run bulk resolution:

```bash
uv run python wfc/scripts/github/pr_threads.py bulk-resolve {owner} {repo} manifest.json
```

This posts the reply message to each thread on GitHub, then calls `resolveReviewThread` to mark it resolved.

**Single thread (ad-hoc):**
```bash
uv run python wfc/scripts/github/pr_threads.py resolve PRRT_... \
  --message "Fixed in abc1234: removed .decode() from text=True subprocess error path"
```

### Step 8: REPORT

Display a final summary:

```
## PR Comment Fixes Complete

**PR:** #{number} — {title}
**Branch:** {headRefName}

### Fixed (N comments)
- {file}:{line} — {brief fix description}
- ...

### Skipped (N comments)
- {file}:{line} — {reason}
- ...

### Responded (N comments)
- {file}:{line} — {reply summary}
- ...

Pushed to {headRefName}. PR updated.
```

---

## Integration with WFC

### Fits After
- `wfc-build` or `wfc-implement` (which create PRs)
- Any workflow that pushes a branch and creates a PR

### Complements
- `wfc-review` — internal review BEFORE creating a PR
- `wfc-pr-comments` — external feedback AFTER PR is created

### Typical Flow
```
wfc-build → Push PR → Reviewers comment → /wfc-pr-comments → Push fixes → Merge
```

## Philosophy

**ELEGANT:** Single skill replaces manual comment-by-comment triage
**PARALLEL:** Fix subagents run concurrently by category
**TOKEN-AWARE:** Only reads files that have comments, not the entire codebase
**SAFE:** User approval gate before any fixes are applied


ARGUMENTS: #36

---

you didnt clear the conflicts